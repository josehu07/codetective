//! API adapters for various AI model providers.

use serde::{Deserialize, Serialize};

use serde_json::Number;

use crate::api_selection::ApiProvider;
use crate::utils::error::{ApiKeyCheckError, ApiMakeCallError};

mod claude;
mod gemini;
mod groqcl;
mod openai;
mod openrt;

/// "Generic" API client.
pub(crate) enum ApiClient {
    OpenAI(openai::ApiClient),
    Claude(claude::ApiClient),
    Gemini(gemini::ApiClient),
    OpenRt(openrt::ApiClient),
    GroqCl(groqcl::ApiClient),
}

impl ApiClient {
    /// Creates a new API client for the given provider with the given API key.
    /// Only successful if passes the API key validity check.
    pub(crate) async fn new(
        provider: ApiProvider,
        api_key: String,
    ) -> Result<Self, ApiKeyCheckError> {
        // some adapters support a free-quota API key when key not given
        assert_ne!(provider, ApiProvider::Null);
        let api_key = (provider != ApiProvider::Free).then_some(api_key);

        match provider {
            ApiProvider::OpenAI => Ok(Self::OpenAI(openai::ApiClient::new(api_key).await?)),
            ApiProvider::Claude => Ok(Self::Claude(claude::ApiClient::new(api_key).await?)),
            ApiProvider::Gemini => Ok(Self::Gemini(gemini::ApiClient::new(api_key).await?)),
            ApiProvider::OpenRt => Ok(Self::OpenRt(openrt::ApiClient::new(api_key).await?)),
            ApiProvider::GroqCl => Ok(Self::GroqCl(groqcl::ApiClient::new(api_key).await?)),

            ApiProvider::Free => {
                // randomly choose an adapter that might have free quota availability
                let freeable_providers = [
                    ApiProvider::Gemini,
                    ApiProvider::OpenRt,
                    ApiProvider::GroqCl,
                ];
                let provider_idx = (getrandom::u32()? as usize) % freeable_providers.len();

                match freeable_providers[provider_idx] {
                    ApiProvider::Gemini => Ok(Self::Gemini(gemini::ApiClient::new(api_key).await?)),
                    ApiProvider::OpenRt => Ok(Self::OpenRt(openrt::ApiClient::new(api_key).await?)),
                    ApiProvider::GroqCl => Ok(Self::GroqCl(groqcl::ApiClient::new(api_key).await?)),
                    _ => unreachable!(),
                }
            }

            _ => unreachable!(),
        }
    }

    /// Returns the provider of this API client.
    pub(crate) fn provider(&self) -> ApiProvider {
        match self {
            Self::OpenAI(_) => ApiProvider::OpenAI,
            Self::Claude(_) => ApiProvider::Claude,
            Self::Gemini(_) => ApiProvider::Gemini,
            Self::OpenRt(_) => ApiProvider::OpenRt,
            Self::GroqCl(_) => ApiProvider::GroqCl,
        }
    }

    /// Makes an API call to my provider and waits for the response: a likelihood
    /// score and a short text of reasoning.
    pub(crate) async fn call(&self, code: &str) -> Result<(u8, String), ApiMakeCallError> {
        let result = match self {
            Self::OpenAI(client) => client.call(Self::prompt(code)).await,
            Self::Claude(client) => client.call(Self::prompt(code)).await,
            Self::Gemini(client) => client.call(Self::prompt(code)).await,
            Self::OpenRt(client) => client.call(Self::prompt(code)).await,
            Self::GroqCl(client) => client.call(Self::prompt(code)).await,
        };

        if let Err(err) = &result {
            log::error!("API call failed: {}", err);
        }
        result
    }

    /// Handcrafted AI likelihood detection prompt.
    #[inline]
    fn prompt(code: &str) -> String {
        format!("
I need you to analyze this code snippet to determine how likely was it generated by an AI language model:

CODE BEGINS HERE
{code}
CODE ENDS HERE

Please consider:
1. The code's structure and syntax
2. Use of comments and documentation
3. Variable naming conventions
4. Error handling approaches
5. Overall styling consistency

You must use this exact JSON output schema, and make sure to produce a valid JSON output:
{{ \"score\": number, \"reason\": string }}

Where:
- 'score' is a percentage score integer between 0 and 100 (inclusive) indicating the likelihood of code being AI generated
- 'reason' is a short explanation of the reasoning behind the score, which must be no longer than 150 words
")
    }
}

/// Expected JSON output schema from responses.
#[derive(Serialize, Deserialize, Debug)]
struct DetectionResultPair {
    score: Number,
    reason: String,
}
